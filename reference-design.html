<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Railroad Tycoon HTML5</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            display: flex;
            flex-direction: column; /* Allow title and canvas stacking */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #ffffff; /* White background */
            font-family: 'Arial', sans-serif; /* Default font for any other text */
        }
        canvas {
            border: 3px solid #1a252f; /* Darker border */
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            border-radius: 8px; /* Rounded corners for the canvas */
        }
        h1 {
            font-family: 'Press Start 2P', cursive;
            color: #ecf0f1; /* Light color for title */
            margin-bottom: 20px;
            font-size: 28px;
            text-shadow: 2px 2px #1a252f;
        }
    </style>
</head>
<body>
    <h1>Railroad Tycoon</h1>
    <canvas id="gameCanvas"></canvas>

    <script>
        // Ensure the script runs after the canvas element is in the DOM
        window.onload = function() {
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) {
                console.error("Canvas element not found!");
                return;
            }
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error("Could not get 2D context!");
                return;
            }

            // Game constants
            const MAP_COLS = 25; 
            const MAP_ROWS = 25; 
            const TILE_WIDTH_HALF = 32; 
            const TILE_HEIGHT_HALF = 16; 
            
            canvas.width = (MAP_COLS + MAP_ROWS) * TILE_WIDTH_HALF + TILE_WIDTH_HALF * 2; 
            canvas.height = (MAP_COLS + MAP_ROWS) * TILE_HEIGHT_HALF + TILE_HEIGHT_HALF * 8; 

            const originX = canvas.width / 2;
            const originY = TILE_HEIGHT_HALF * MAP_ROWS * 0.5 + 50; 

            // Colors
            const COLORS = {
                grass: '#8BC34A', water: '#03A9F4', sand: '#FFC107',
                cityGround: '#BDBDBD', cityWall1: '#795548', cityRoof1: '#A1887F',
                cityWall2: '#8D6E63', cityRoof2: '#BCAAA4', cityWall3: '#6D4C41', cityRoof3: '#90A4AE', 
                track: '#5D4037', trackTies: '#8D6E63', 
                trainEngine: '#D32F2F', trainCarriage: '#F44336', trainHighlight: '#FFCDD2',
                smokestack: '#424242', trainShadow: 'rgba(0, 0, 0, 0.25)', 
                cowcatcher: '#616161', 
                mountain: '#795548', mountainSnow: '#E0E0E0', 
                forestTrunk: '#5D4037', forestCanopy: '#388E3C',
                sky: '#87CEEB', cityNameText: '#212121', cityNameBackground: 'rgba(255, 255, 255, 0.7)',
            };

            const TILE_TYPE = { GRASS: 0, WATER: 1, SAND: 2, CITY: 3, MOUNTAIN: 4, FOREST: 5 };

            let mapData = []; 
            let featureLayouts = {}; 
            let placedCitiesCoords = []; 

            const CITY_NAMES = [
                "Springfield", "Riverside", "Oakdale", "Fairview", "Madison", "Georgetown", "Arlington", "Salem",
                "Greenville", "Franklin", "Clinton", "Bristol", "Dover", "Manchester", "Chester", "Milton",
                "Auburn", "Bedford", "Burlington", "Clayton", "Dayton", "Harrison", "Jackson", "Lexington"
            ]; 
            let availableCityNames = [...CITY_NAMES];

            let trainPath = [];
            let smokeParticles = []; // Added for smoke effects
            let train = { 
                segmentIndex: 0, 
                progress: 0, 
                speed: 0.008, 
                numCarriages: 7, 
                carriageSpacingProgress: 0.8,
                wheelPhase: 0,
                carriageTypes: ['engine', 'passenger', 'freight', 'passenger', 'tank', 'freight', 'caboose']
            };

            // --- Utility Functions ---
            function isoToScreen(isoX, isoY) {
                const screenX = originX + (isoX - isoY) * TILE_WIDTH_HALF;
                const screenY = originY + (isoX + isoY) * TILE_HEIGHT_HALF;
                return { x: screenX, y: screenY };
            }

            function LightenDarkenColor(col, amt) {
                let usePound = false; if (col[0] === "#") { col = col.slice(1); usePound = true; }
                const num = parseInt(col, 16);
                let r = (num >> 16) + amt; if (r > 255) r = 255; else if (r < 0) r = 0;
                let g = ((num >> 8) & 0x00FF) + amt; if (g > 255) g = 255; else if (g < 0) g = 0;
                let b = (num & 0x0000FF) + amt; if (b > 255) b = 255; else if (b < 0) b = 0;
                return (usePound ? "#" : "") + (r << 16 | g << 8 | b).toString(16).padStart(6, '0');
            }
            
            function seededRandom(x, y, seed = 0) {
                const x_val = Number(x) || 0.1; const y_val = Number(y) || 0.1; const seed_val = Number(seed) || 0.1;
                let val = Math.sin(x_val * 12.9898 + y_val * 78.233 + seed_val * 5.4321) * 43758.5453123;
                return val - Math.floor(val); 
            }

            // --- A* Pathfinding Algorithm (condensed) ---
            function aStar(startNode, goalNode, gridData, cols, rows) {
                function heuristic(nodeA, nodeB) { return Math.abs(nodeA.x - nodeB.x) + Math.abs(nodeA.y - nodeB.y); }
                function getNeighbors(node, cGD, nC, nR) { const neigh = []; const dirs = [[0,-1],[0,1],[-1,0],[1,0]]; for(const[dx,dy]of dirs){ const nX=node.x+dx; const nY=node.y+dy; if(nX>=0&&nX<nC&&nY>=0&&nY<nR){const tT=cGD[nY][nX]; if(tT!==TILE_TYPE.MOUNTAIN&&tT!==TILE_TYPE.FOREST&&tT!==TILE_TYPE.WATER)neigh.push({x:nX,y:nY});}} return neigh;}
                function reconstructPath(cF, curr) { const tP=[curr]; while(cF[`${curr.x}-${curr.y}`]){curr=cF[`${curr.x}-${curr.y}`];tP.unshift(curr);} return tP;}
                const oS=[startNode]; const cF={}; const gS={}; const fS={};
                for(let rI=0;rI<rows;rI++){for(let cI=0;cI<cols;cI++){gS[`${cI}-${rI}`]=Infinity;fS[`${cI}-${rI}`]=Infinity;}}
                gS[`${startNode.x}-${startNode.y}`]=0; fS[`${startNode.x}-${startNode.y}`]=heuristic(startNode,goalNode);
                while(oS.length>0){oS.sort((a,b)=>fS[`${a.x}-${a.y}`]-fS[`${b.x}-${b.y}`]); const curr=oS.shift(); if(curr.x===goalNode.x&&curr.y===goalNode.y)return reconstructPath(cF,curr);
                const neighs=getNeighbors(curr,gridData,cols,rows); for(const neigh of neighs){ const nTT=gridData[neigh.y][neigh.x]; if(nTT===TILE_TYPE.MOUNTAIN||nTT===TILE_TYPE.FOREST||nTT===TILE_TYPE.WATER)continue;
                let cost=1; if(nTT===TILE_TYPE.CITY)cost=50; const tGS=gS[`${curr.x}-${curr.y}`]+cost;
                if(tGS<gS[`${neigh.x}-${neigh.y}`]){cF[`${neigh.x}-${neigh.y}`]=curr;gS[`${neigh.x}-${neigh.y}`]=tGS;fS[`${neigh.x}-${neigh.y}`]=tGS+heuristic(neigh,goalNode);if(!oS.some(n=>n.x===neigh.x&&n.y===neigh.y))oS.push(neigh);}}}
                return null; 
            }
            function validatePathSegment(segment, gridData) {
                if (!segment || segment.length === 0) return true; 
                for (const point of segment) { if (point.x < 0 || point.x >= MAP_COLS || point.y < 0 || point.y >= MAP_ROWS) {console.error("Path point out of bounds:", point); return false;}
                const tileType = gridData[point.y][point.x]; if (tileType === TILE_TYPE.MOUNTAIN || tileType === TILE_TYPE.FOREST || tileType === TILE_TYPE.WATER) { console.warn("Path validation fail:", point, "Type:", tileType); return false;}}
                return true; 
            }

            // --- Drawing Functions ---
            function drawDiamond(screenX, screenY, fillColor, strokeColor = null) { 
                ctx.beginPath(); ctx.moveTo(screenX, screenY - TILE_HEIGHT_HALF); ctx.lineTo(screenX + TILE_WIDTH_HALF, screenY);
                ctx.lineTo(screenX, screenY + TILE_HEIGHT_HALF); ctx.lineTo(screenX - TILE_WIDTH_HALF, screenY);
                ctx.closePath(); ctx.fillStyle = fillColor; ctx.fill();
                if (strokeColor) { ctx.strokeStyle = strokeColor; ctx.lineWidth = 1; ctx.stroke(); }
            }
            function drawWheel(ctx, radius, phase, wheelColor, spokeColor) {
                // Main wheel
                ctx.fillStyle = wheelColor;
                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.fill();

                // Outer rim
                ctx.strokeStyle = LightenDarkenColor(wheelColor, -50);
                ctx.lineWidth = Math.max(2, radius * 0.15);
                ctx.beginPath();
                ctx.arc(0, 0, radius * 0.9, 0, Math.PI * 2);
                ctx.stroke();

                // Multiple spokes (6 spokes like real train wheels)
                ctx.save();
                ctx.rotate(phase);
                ctx.strokeStyle = spokeColor;
                ctx.lineWidth = Math.max(2, radius * 0.12);
                
                for (let i = 0; i < 6; i++) {
                    ctx.save();
                    ctx.rotate((i * Math.PI * 2) / 6);
                    ctx.beginPath();
                    ctx.moveTo(radius * 0.2, 0);
                    ctx.lineTo(radius * 0.75, 0);
                    ctx.stroke();
                    ctx.restore();
                }
                ctx.restore();
                
                // Center hub
                ctx.fillStyle = LightenDarkenColor(wheelColor, -30);
                ctx.beginPath();
                ctx.arc(0, 0, radius * 0.25, 0, Math.PI * 2);
                ctx.fill();
            }

            function drawCoupler(ctx, x, y, angle, isRear = false) {
                const couplerLength = 8;
                const couplerHeight = 3;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                
                const xOffset = isRear ? -couplerLength/2 : couplerLength/2;
                ctx.fillStyle = '#444444';
                ctx.fillRect(xOffset - couplerLength/2, -couplerHeight/2, couplerLength, couplerHeight);
                
                // Coupler head
                ctx.fillStyle = '#333333';
                const headSize = 4;
                ctx.fillRect(xOffset + (isRear ? -couplerLength/2 : couplerLength/2) - headSize/2, -headSize/2, headSize, headSize);
                
                ctx.restore();
            }

            function drawIsometricCar(ctx, carWidth, carHeight, carDepth, bodyColor, roofColor, details) {
                const halfWidth = carWidth / 2;
                const halfDepth = carDepth / 2;
                
                // Draw 3D isometric car body
                // Front face
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.moveTo(-halfWidth, -carHeight);
                ctx.lineTo(halfWidth, -carHeight);
                ctx.lineTo(halfWidth, 0);
                ctx.lineTo(-halfWidth, 0);
                ctx.closePath();
                ctx.fill();
                
                // Right side face (darker)
                ctx.fillStyle = LightenDarkenColor(bodyColor, -20);
                ctx.beginPath();
                ctx.moveTo(halfWidth, -carHeight);
                ctx.lineTo(halfWidth + halfDepth, -carHeight - halfDepth);
                ctx.lineTo(halfWidth + halfDepth, -halfDepth);
                ctx.lineTo(halfWidth, 0);
                ctx.closePath();
                ctx.fill();
                
                // Top face (roof)
                ctx.fillStyle = roofColor;
                ctx.beginPath();
                ctx.moveTo(-halfWidth, -carHeight);
                ctx.lineTo(-halfWidth + halfDepth, -carHeight - halfDepth);
                ctx.lineTo(halfWidth + halfDepth, -carHeight - halfDepth);
                ctx.lineTo(halfWidth, -carHeight);
                ctx.closePath();
                ctx.fill();
                
                // Add details if provided
                if (details && details.windows) {
                    ctx.fillStyle = details.windowColor || '#B3E5FC';
                    const windowCount = details.windows;
                    const windowWidth = carWidth / (windowCount + 1);
                    const windowHeight = carHeight * 0.3;
                    
                    for(let i = 0; i < windowCount; i++) {
                        const windowX = -halfWidth + windowWidth * 0.5 + i * windowWidth;
                        ctx.fillRect(windowX, -carHeight * 0.8, windowWidth * 0.6, windowHeight);
                    }
                }
                
                if (details && details.cargo) {
                    ctx.fillStyle = details.cargoColor || '#6D4C41';
                    // Draw cargo on top
                    ctx.fillRect(-halfWidth * 0.6 + halfDepth * 0.2, -carHeight - halfDepth * 0.8, carWidth * 0.3, halfDepth * 0.4);
                    ctx.fillRect(-halfWidth * 0.2 + halfDepth * 0.3, -carHeight - halfDepth * 0.9, carWidth * 0.4, halfDepth * 0.5);
                }
                
                // Outlines for definition
                ctx.strokeStyle = LightenDarkenColor(bodyColor, -50);
                ctx.lineWidth = 1;
                
                // Front face outline
                ctx.beginPath();
                ctx.moveTo(-halfWidth, -carHeight);
                ctx.lineTo(halfWidth, -carHeight);
                ctx.lineTo(halfWidth, 0);
                ctx.lineTo(-halfWidth, 0);
                ctx.closePath();
                ctx.stroke();
                
                // Side face outline
                ctx.beginPath();
                ctx.moveTo(halfWidth, -carHeight);
                ctx.lineTo(halfWidth + halfDepth, -carHeight - halfDepth);
                ctx.lineTo(halfWidth + halfDepth, -halfDepth);
                ctx.lineTo(halfWidth, 0);
                ctx.stroke();
                
                // Top face outline
                ctx.beginPath();
                ctx.moveTo(-halfWidth, -carHeight);
                ctx.lineTo(-halfWidth + halfDepth, -carHeight - halfDepth);
                ctx.lineTo(halfWidth + halfDepth, -carHeight - halfDepth);
                ctx.lineTo(halfWidth, -carHeight);
                ctx.stroke();
            }

            function drawPassengerCar(ctx, carWidth, carHeight, wheelPhase, verticalAdjust) {
                const bodyColor = '#2E7D32';
                const roofColor = '#1B5E20';
                const carDepth = carHeight * 0.6;
                
                drawIsometricCar(ctx, carWidth, carHeight, carDepth, bodyColor, roofColor, {
                    windows: 4,
                    windowColor: '#B3E5FC'
                });
                
                // Wheels
                const wheelRadius = carHeight * 0.25;
                const wheelColor = '#2d2d2d';
                const spokeColor = '#aaaaaa';
                
                ctx.save();
                ctx.translate(carWidth * 0.25, carHeight * 0.15 * verticalAdjust);
                ctx.scale(1, 0.5);
                drawWheel(ctx, wheelRadius, wheelPhase, wheelColor, spokeColor);
                ctx.restore();
                
                ctx.save();
                ctx.translate(-carWidth * 0.25, carHeight * 0.15 * verticalAdjust);
                ctx.scale(1, 0.5);
                drawWheel(ctx, wheelRadius, wheelPhase + Math.PI / 3, wheelColor, spokeColor);
                ctx.restore();
            }

            function drawFreightCar(ctx, carWidth, carHeight, wheelPhase, verticalAdjust) {
                const bodyColor = '#8D6E63';
                const roofColor = '#6D4C41';
                const carDepth = carHeight * 0.6;
                
                drawIsometricCar(ctx, carWidth, carHeight, carDepth, bodyColor, roofColor, {
                    cargo: true,
                    cargoColor: '#5D4037'
                });
                
                // Wheels
                const wheelRadius = carHeight * 0.25;
                const wheelColor = '#2d2d2d';
                const spokeColor = '#aaaaaa';
                
                ctx.save();
                ctx.translate(carWidth * 0.25, carHeight * 0.15 * verticalAdjust);
                ctx.scale(1, 0.5);
                drawWheel(ctx, wheelRadius, wheelPhase, wheelColor, spokeColor);
                ctx.restore();
                
                ctx.save();
                ctx.translate(-carWidth * 0.25, carHeight * 0.15 * verticalAdjust);
                ctx.scale(1, 0.5);
                drawWheel(ctx, wheelRadius, wheelPhase + Math.PI / 3, wheelColor, spokeColor);
                ctx.restore();
            }

            function drawTankCar(ctx, carWidth, carHeight, wheelPhase, verticalAdjust) {
                const tankColor = '#37474F';
                const highlightColor = '#546E7A';
                const carDepth = carHeight * 0.5;
                const halfWidth = carWidth / 2;
                const halfDepth = carDepth / 2;
                const tankRadius = carHeight * 0.35;
                
                // Draw isometric cylindrical tank
                // Tank front (ellipse)
                ctx.fillStyle = tankColor;
                ctx.beginPath();
                ctx.ellipse(0, -tankRadius, halfWidth, tankRadius * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Tank body (3D cylinder sides)
                ctx.fillStyle = LightenDarkenColor(tankColor, -15);
                ctx.fillRect(-halfWidth, -tankRadius * 1.6, carWidth, tankRadius * 1.2);
                
                // Tank right side (darker)
                ctx.fillStyle = LightenDarkenColor(tankColor, -25);
                ctx.beginPath();
                ctx.ellipse(halfDepth, -tankRadius - halfDepth, halfWidth, tankRadius * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Support frame (isometric)
                const frameColor = '#424242';
                ctx.fillStyle = frameColor;
                
                // Front support
                ctx.fillRect(-halfWidth, -carHeight * 0.1, carWidth, carHeight * 0.2);
                
                // Side support (isometric)
                ctx.fillStyle = LightenDarkenColor(frameColor, -20);
                ctx.beginPath();
                ctx.moveTo(halfWidth, -carHeight * 0.1);
                ctx.lineTo(halfWidth + halfDepth, -carHeight * 0.1 - halfDepth);
                ctx.lineTo(halfWidth + halfDepth, carHeight * 0.1 - halfDepth);
                ctx.lineTo(halfWidth, carHeight * 0.1);
                ctx.closePath();
                ctx.fill();
                
                // Tank details
                ctx.fillStyle = '#616161';
                ctx.fillRect(-3, -tankRadius * 1.8, 6, 8); // Valve
                
                // Wheels
                const wheelRadius = carHeight * 0.25;
                const wheelColor = '#2d2d2d';
                const spokeColor = '#aaaaaa';
                
                ctx.save();
                ctx.translate(carWidth * 0.25, carHeight * 0.15 * verticalAdjust);
                ctx.scale(1, 0.5);
                drawWheel(ctx, wheelRadius, wheelPhase, wheelColor, spokeColor);
                ctx.restore();
                
                ctx.save();
                ctx.translate(-carWidth * 0.25, carHeight * 0.15 * verticalAdjust);
                ctx.scale(1, 0.5);
                drawWheel(ctx, wheelRadius, wheelPhase + Math.PI / 3, wheelColor, spokeColor);
                ctx.restore();
                
                // Outlines
                ctx.strokeStyle = LightenDarkenColor(tankColor, -50);
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.ellipse(0, -tankRadius, halfWidth, tankRadius * 0.6, 0, 0, Math.PI * 2);
                ctx.stroke();
            }

            function drawCaboose(ctx, carWidth, carHeight, wheelPhase, verticalAdjust) {
                const bodyColor = '#C62828';
                const roofColor = '#B71C1C';
                const carDepth = carHeight * 0.6;
                
                drawIsometricCar(ctx, carWidth, carHeight, carDepth, bodyColor, roofColor, {
                    windows: 2,
                    windowColor: '#FFEB3B'
                });
                
                // Draw cupola (observation deck) - isometric style
                const cupolaWidth = carWidth * 0.4;
                const cupolaHeight = carHeight * 0.3;
                const cupolaDepth = carDepth * 0.7;
                const halfCupolaWidth = cupolaWidth / 2;
                const halfCupolaDepth = cupolaDepth / 2;
                
                // Cupola front face
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.moveTo(-halfCupolaWidth, -carHeight - cupolaHeight);
                ctx.lineTo(halfCupolaWidth, -carHeight - cupolaHeight);
                ctx.lineTo(halfCupolaWidth, -carHeight);
                ctx.lineTo(-halfCupolaWidth, -carHeight);
                ctx.closePath();
                ctx.fill();
                
                // Cupola side face
                ctx.fillStyle = LightenDarkenColor(bodyColor, -20);
                ctx.beginPath();
                ctx.moveTo(halfCupolaWidth, -carHeight - cupolaHeight);
                ctx.lineTo(halfCupolaWidth + halfCupolaDepth, -carHeight - cupolaHeight - halfCupolaDepth);
                ctx.lineTo(halfCupolaWidth + halfCupolaDepth, -carHeight - halfCupolaDepth);
                ctx.lineTo(halfCupolaWidth, -carHeight);
                ctx.closePath();
                ctx.fill();
                
                // Cupola roof
                ctx.fillStyle = roofColor;
                ctx.beginPath();
                ctx.moveTo(-halfCupolaWidth, -carHeight - cupolaHeight);
                ctx.lineTo(-halfCupolaWidth + halfCupolaDepth, -carHeight - cupolaHeight - halfCupolaDepth);
                ctx.lineTo(halfCupolaWidth + halfCupolaDepth, -carHeight - cupolaHeight - halfCupolaDepth);
                ctx.lineTo(halfCupolaWidth, -carHeight - cupolaHeight);
                ctx.closePath();
                ctx.fill();
                
                // Cupola windows
                ctx.fillStyle = '#FFEB3B';
                ctx.fillRect(-cupolaWidth * 0.3, -carHeight - cupolaHeight * 0.7, cupolaWidth * 0.25, cupolaHeight * 0.4);
                ctx.fillRect(cupolaWidth * 0.05, -carHeight - cupolaHeight * 0.7, cupolaWidth * 0.25, cupolaHeight * 0.4);
                
                // Wheels
                const wheelRadius = carHeight * 0.25;
                const wheelColor = '#2d2d2d';
                const spokeColor = '#aaaaaa';
                
                ctx.save();
                ctx.translate(carWidth * 0.25, carHeight * 0.15 * verticalAdjust);
                ctx.scale(1, 0.5);
                drawWheel(ctx, wheelRadius, wheelPhase, wheelColor, spokeColor);
                ctx.restore();
                
                ctx.save();
                ctx.translate(-carWidth * 0.25, carHeight * 0.15 * verticalAdjust);
                ctx.scale(1, 0.5);
                drawWheel(ctx, wheelRadius, wheelPhase + Math.PI / 3, wheelColor, spokeColor);
                ctx.restore();
            }

            function drawEngine(ctx, engineWidth, engineHeight, wheelPhase, verticalAdjust) {
                /* A more detailed, classic steam‑locomotive:
                   – shaded cylindrical boiler
                   – rear cab built with the shared isometric‑car helper
                   – chimney with lip
                   – cow‑catcher / pilot at the front
                   – two large driving wheels linked by a connecting rod
                */
                
                // --- Basic dimensions ------------------------------------------------------
                const carDepth      = engineHeight * 0.6;       // same depth logic as other cars
                const boilerLength  = engineWidth  * 0.75;
                const boilerRadius  = engineHeight * 0.45;
                const cabWidth      = engineWidth  * 0.35;
                const halfDepth     = carDepth / 2;
                
                // --- Colours --------------------------------------------------------------
                const cabBodyColor  = COLORS.trainEngine;                 // keep red cab
                const cabRoofColor  = LightenDarkenColor(cabBodyColor,-30);
                const boilerColor   = LightenDarkenColor(cabBodyColor,-20);
                const chimneyColor  = COLORS.smokestack;
                const metalDark     = '#3e3e3e';
                const metalLight    = '#777777';
                
                // --------------------------------------------------------------------------
                // Draw CAB (reuse isometric helper; placed slightly behind boiler centre)
                // --------------------------------------------------------------------------
                ctx.save();
                ctx.translate(-engineWidth * 0.45, 0); // shift to the rear of loco
                drawIsometricCar(ctx, cabWidth, engineHeight * 0.9, carDepth,
                                 cabBodyColor, cabRoofColor,
                                 { windows: 1, windowColor: '#B3E5FC' });
                ctx.restore();
                
                // --------------------------------------------------------------------------
                // Draw BOILER – shaded cylinder
                // --------------------------------------------------------------------------
                // Body (rectangle side)
                ctx.fillStyle = LightenDarkenColor(boilerColor, -15);
                ctx.fillRect(-boilerLength * 0.5, -boilerRadius * 1.4,
                              boilerLength,           boilerRadius * 1.2);
                
                // Rear ellipse cap
                ctx.fillStyle = boilerColor;
                ctx.beginPath();
                ctx.ellipse(-boilerLength * 0.5, -boilerRadius,
                            boilerRadius, boilerRadius * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Front ellipse cap (darker for 3‑D cue)
                ctx.fillStyle = LightenDarkenColor(boilerColor, -25);
                ctx.beginPath();
                ctx.ellipse( boilerLength * 0.5, -boilerRadius,
                             boilerRadius, boilerRadius * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Thin outline on caps
                ctx.strokeStyle = LightenDarkenColor(boilerColor, -50);
                ctx.lineWidth   = 1;
                ['-','+'].forEach(sign => {
                    const sx = (sign === '-') ? -boilerLength * 0.5 : boilerLength * 0.5;
                    ctx.beginPath();
                    ctx.ellipse(sx, -boilerRadius,
                                boilerRadius, boilerRadius * 0.6, 0, 0, Math.PI * 2);
                    ctx.stroke();
                });
                
                // --------------------------------------------------------------------------
                // Chimney / smokestack
                // --------------------------------------------------------------------------
                const chimneyWidth  = boilerRadius * 0.5;
                const chimneyHeight = boilerRadius * 1.1;
                const chimneyX      = boilerLength * 0.25;
                const chimneyY      = -boilerRadius * 1.8;
                
                // Lip / opening
                ctx.fillStyle = chimneyColor;
                ctx.beginPath();
                ctx.ellipse(chimneyX, chimneyY + chimneyHeight * 0.1,
                            chimneyWidth, chimneyWidth * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Stack
                ctx.fillRect(chimneyX - chimneyWidth,
                             chimneyY,
                             chimneyWidth * 2,
                             chimneyHeight);
                
                // --------------------------------------------------------------------------
                // Cow‑catcher (pilot)
                // --------------------------------------------------------------------------
                const catcherFront  =  boilerLength * 0.55;
                const catcherWidth  =  engineWidth  * 0.22;
                const catcherHeight =  engineHeight * 0.4;
                
                ctx.fillStyle = metalDark;
                ctx.beginPath();
                ctx.moveTo(catcherFront, 0);
                ctx.lineTo(catcherFront + catcherWidth, -catcherHeight * 0.5);
                ctx.lineTo(catcherFront + catcherWidth,  catcherHeight * 0.5);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = metalLight;
                ctx.stroke();
                
                // --------------------------------------------------------------------------
                // Driving wheels (two big ones) + connecting rod
                // --------------------------------------------------------------------------
                const wheelRadius  = engineHeight * 0.28;
                const wheelColor   = '#2d2d2d';
                const spokeColor   = '#bbbbbb';
                
                const wheelPositions = [
                    -engineWidth * 0.15,   // rear driver
                     engineWidth * 0.20    // front driver
                ];
                
                wheelPositions.forEach((xPos, idx) => {
                    ctx.save();
                    ctx.translate(xPos, engineHeight * 0.15 * verticalAdjust);
                    ctx.scale(1, 0.5); // isometric squash
                    drawWheel(ctx, wheelRadius,
                              wheelPhase + (idx ? Math.PI / 3 : 0),
                              wheelColor, spokeColor);
                    ctx.restore();
                });
                
                // Connecting rod (simple bar linking wheel hubs)
                ctx.strokeStyle = metalLight;
                ctx.lineWidth   = wheelRadius * 0.15;
                ctx.beginPath();
                ctx.moveTo(wheelPositions[0], engineHeight * 0.15 * verticalAdjust);
                ctx.lineTo(wheelPositions[1], engineHeight * 0.15 * verticalAdjust);
                ctx.stroke();
            }

            function drawBuilding(centerX, baseY, buildingWidthHalf, buildingDepthHalf, buildingHeight, wallColor, roofColor) { 
                const screenYTop = baseY - buildingHeight;
                ctx.beginPath(); ctx.moveTo(centerX, screenYTop - buildingDepthHalf); ctx.lineTo(centerX + buildingWidthHalf, screenYTop);
                ctx.lineTo(centerX, screenYTop + buildingDepthHalf); ctx.lineTo(centerX - buildingWidthHalf, screenYTop); ctx.closePath();
                ctx.fillStyle = roofColor; ctx.fill(); ctx.strokeStyle = LightenDarkenColor(roofColor, -30); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(centerX - buildingWidthHalf, screenYTop); ctx.lineTo(centerX, screenYTop + buildingDepthHalf);
                ctx.lineTo(centerX, baseY + buildingDepthHalf); ctx.lineTo(centerX - buildingWidthHalf, baseY); ctx.closePath();
                ctx.fillStyle = wallColor; ctx.fill(); ctx.strokeStyle = LightenDarkenColor(wallColor, -30); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(centerX + buildingWidthHalf, screenYTop); ctx.lineTo(centerX, screenYTop + buildingDepthHalf);
                ctx.lineTo(centerX, baseY + buildingDepthHalf); ctx.lineTo(centerX + buildingWidthHalf, baseY); ctx.closePath();
                ctx.fillStyle = LightenDarkenColor(wallColor, -20); ctx.fill(); ctx.strokeStyle = LightenDarkenColor(wallColor, -50); ctx.stroke();
            }

            function drawCityBuildingsOnly(isoX, isoY) {
                const { x: tileCenterX, y: tileCenterY } = isoToScreen(isoX, isoY);
                const cityKey = `city-${isoX}-${isoY}`; 
                if (featureLayouts[cityKey] && featureLayouts[cityKey].buildings) {
                    featureLayouts[cityKey].buildings.forEach(b=>{drawBuilding(tileCenterX+b.offsetX,tileCenterY+b.offsetY,b.buildingWidthHalf,b.buildingDepthHalf,b.buildingHeight,b.wallColor,b.roofColor);});
                } else {
                    console.warn(`No building layout for city at ${isoX},${isoY} during drawCityBuildingsOnly.`);
                }
            }

            function drawMountainFeatureOnly(isoX, isoY) {
                const { x: screenX, y: screenYBase } = isoToScreen(isoX, isoY);
                const mountainHeight = TILE_HEIGHT_HALF * (3 + seededRandom(isoX, isoY, 100) * 2); 
                const screenYPeak = screenYBase - mountainHeight;
                
                ctx.beginPath(); ctx.moveTo(screenX, screenYPeak); ctx.lineTo(screenX - TILE_WIDTH_HALF, screenYBase); 
                ctx.lineTo(screenX, screenYBase + TILE_HEIGHT_HALF); ctx.closePath();
                ctx.fillStyle = COLORS.mountain; ctx.fill(); ctx.strokeStyle = LightenDarkenColor(COLORS.mountain, -30); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(screenX, screenYPeak); ctx.lineTo(screenX + TILE_WIDTH_HALF, screenYBase); 
                ctx.lineTo(screenX, screenYBase + TILE_HEIGHT_HALF); ctx.closePath();
                ctx.fillStyle = LightenDarkenColor(COLORS.mountain, -20); ctx.fill(); ctx.strokeStyle = LightenDarkenColor(COLORS.mountain, -50); ctx.stroke();
                if(mountainHeight > TILE_HEIGHT_HALF * 4){ 
                    ctx.beginPath();ctx.moveTo(screenX,screenYPeak);ctx.lineTo(screenX+TILE_WIDTH_HALF*0.4,screenYPeak+mountainHeight*0.3);ctx.lineTo(screenX,screenYPeak+mountainHeight*0.4);
                    ctx.lineTo(screenX-TILE_WIDTH_HALF*0.4,screenYPeak+mountainHeight*0.3);ctx.closePath();ctx.fillStyle=COLORS.mountainSnow;ctx.fill();
                }
            }
            
            function drawForestTreesOnly(isoX, isoY) {
                const { x: screenX, y: screenYBase } = isoToScreen(isoX, isoY);
                const forestKey = `forest-${isoX}-${isoY}`; 
                if (featureLayouts[forestKey] && featureLayouts[forestKey].trees) { 
                    featureLayouts[forestKey].trees.forEach(p=>{const tCX=screenX+p.dx;const tBY=screenYBase+p.dy;const trH=TILE_HEIGHT_HALF*1.5*p.scale;const cR=TILE_WIDTH_HALF*0.3*p.scale;
                    const cCY=tBY-trH;ctx.fillStyle=COLORS.forestTrunk;ctx.fillRect(tCX-3*p.scale,tBY-trH,6*p.scale,trH);
                    ctx.beginPath();ctx.arc(tCX,cCY,cR,0,Math.PI*2);ctx.fillStyle=COLORS.forestCanopy;ctx.fill();ctx.strokeStyle=LightenDarkenColor(COLORS.forestCanopy,-30);ctx.stroke();});
                } else {
                     console.warn(`No tree layout for forest at ${isoX},${isoY} during drawForestTreesOnly.`);
                }
            }

            function drawCityName(isoX, isoY){
                const { x: tileCenterX, y: tileCenterY } = isoToScreen(isoX, isoY);
                const cityKey = `city-${isoX}-${isoY}`;
                if(featureLayouts[cityKey]&&featureLayouts[cityKey].name){
                    ctx.font="bold 12px Arial";ctx.textAlign="center";const nameTxt=featureLayouts[cityKey].name;const txtMet=ctx.measureText(nameTxt);
                    const txtW=txtMet.width;const txtH=12;const pad=4;const nX=tileCenterX;const nY=tileCenterY-TILE_HEIGHT_HALF*2.0-txtH; 
                    ctx.fillStyle=COLORS.cityNameBackground;ctx.fillRect(nX-txtW/2-pad,nY-txtH-pad+2,txtW+pad*2,txtH+pad*2-2);
                    ctx.fillStyle=COLORS.cityNameText;ctx.fillText(nameTxt,nX,nY);
                }
            }
            
            // --- Map Generation ---
            function generateMap() {
                mapData = []; featureLayouts = {}; availableCityNames = [...CITY_NAMES]; placedCitiesCoords = [];
                // 1. Generate terrain
                for(let r=0;r<MAP_ROWS;r++){mapData[r]=[];for(let c=0;c<MAP_COLS;c++){
                    let t=TILE_TYPE.WATER;const rF=seededRandom(c,r,300);const dX=Math.abs(c-MAP_COLS/2);const dY=Math.abs(r-MAP_ROWS/2);
                    const nX=dX/(MAP_COLS/2.5);const nY=dY/(MAP_ROWS/2.5);const iF=Math.sqrt(nX*nX+nY*nY);
                    if(iF<0.8){t=TILE_TYPE.GRASS;if(rF<0.15)t=TILE_TYPE.FOREST;else if(rF<0.25&&iF<0.7)t=TILE_TYPE.MOUNTAIN;}
                    else if(iF<1.0)t=TILE_TYPE.SAND;
                    const lR=seededRandom(c,r,301);if(((c>MAP_COLS*0.15&&c<MAP_COLS*0.35&&r>MAP_ROWS*0.15&&r<MAP_ROWS*0.35&&lR>0.7)||(c>MAP_COLS*0.65&&c<MAP_COLS*0.85&&r>MAP_ROWS*0.65&&r<MAP_ROWS*0.85&&lR>0.7)))t=(lR>0.85)?TILE_TYPE.WATER:TILE_TYPE.SAND;
                    mapData[r][c]=t;
                }}
                // 2. Place cities & pre-generate their visual layouts
                let cP=0;const mC=Math.floor((MAP_ROWS*MAP_COLS)/100)+2; 
                for(let att=0;att<2000 && cP<mC;att++){ 
                    const rA=Math.floor(seededRandom(att,att*2,400)*(MAP_ROWS-2))+1;const cA=Math.floor(seededRandom(att*2,att,401)*(MAP_COLS-2))+1;
                    if(rA>=0&&rA<MAP_ROWS&&cA>=0&&cA<MAP_COLS&&mapData[rA][cA]===TILE_TYPE.GRASS){
                        let suit=true;
                        for(let dr=-1;dr<=1;dr++){for(let dc=-1;dc<=1;dc++){
                            const nr=rA+dr; const nc=cA+dc;
                            if(nr>=0&&nr<MAP_ROWS&&nc>=0&&nc<MAP_COLS){ if(mapData[nr][nc]===TILE_TYPE.WATER||mapData[nr][nc]===TILE_TYPE.MOUNTAIN||mapData[nr][nc]===TILE_TYPE.FOREST||(mapData[nr][nc]===TILE_TYPE.CITY && !(dr===0 && dc===0))){suit=false;break;}} else { suit=false;break; }}if(!suit)break;}
                        if(suit){
                            mapData[rA][cA]=TILE_TYPE.CITY;cP++;
                            const cityKey=`city-${cA}-${rA}`;
                            featureLayouts[cityKey]={ buildings: [], name: '' }; 

                            let cN=`Town ${cP}`;if(availableCityNames.length>0){const nI=Math.floor(Math.random()*availableCityNames.length);cN=availableCityNames.splice(nI,1)[0];}
                            featureLayouts[cityKey].name=cN;
                            placedCitiesCoords.push({x:cA,y:rA,name:cN});
                            
                            const { x: tcX_city, y: tcY_city } = isoToScreen(cA, rA);
                            const numB = 8 + Math.floor(seededRandom(cA, rA, 1) * 5);
                            for (let i = 0; i < numB; i++) {
                                const bSeed=i*10; const oX=(seededRandom(cA,rA,bSeed+1)-0.5)*TILE_WIDTH_HALF*0.8; const oY=(seededRandom(cA,rA,bSeed+2)-0.5)*TILE_HEIGHT_HALF*0.6;
                                const bWH=TILE_WIDTH_HALF*(0.15+seededRandom(cA,rA,bSeed+3)*0.15); const bDH=TILE_HEIGHT_HALF*(0.15+seededRandom(cA,rA,bSeed+4)*0.15);
                                const bH=TILE_HEIGHT_HALF*(0.8+seededRandom(cA,rA,bSeed+5)*0.7); const cSeed=Math.floor(seededRandom(cA,rA,bSeed+6)*3);
                                let wc,rc;if(cSeed===0){wc=COLORS.cityWall1;rc=COLORS.cityRoof1;}else if(cSeed===1){wc=COLORS.cityWall2;rc=COLORS.cityRoof2;}else{wc=COLORS.cityWall3;rc=COLORS.cityRoof3;}
                                featureLayouts[cityKey].buildings.push({offsetX:oX,offsetY:oY,buildingWidthHalf:bWH,buildingDepthHalf:bDH,buildingHeight:bH,wallColor:wc,roofColor:rc});
                            }
                            featureLayouts[cityKey].buildings.sort((a,b)=>{const aVY=(tcY_city+a.offsetY)-a.buildingHeight;const bVY=(tcY_city+b.offsetY)-b.buildingHeight;if(aVY!==bVY)return aVY-bVY;return(tcX_city+a.offsetX)-(tcX_city+b.offsetX);});
                        }
                    }
                }
                for (let r_forest = 0; r_forest < MAP_ROWS; r_forest++) {
                    for (let c_forest = 0; c_forest < MAP_COLS; c_forest++) {
                        if (mapData[r_forest][c_forest] === TILE_TYPE.FOREST) {
                            const forestKey = `forest-${c_forest}-${r_forest}`;
                            featureLayouts[forestKey] = { trees: [] }; 
                            const { x: screenX_forest, y: screenYBase_forest } = isoToScreen(c_forest, r_forest);
                            const numTrees = 2 + Math.floor(seededRandom(c_forest, r_forest, 200) * 3);
                            for (let i = 0; i < numTrees; i++) {
                                const tS = i * 10;
                                featureLayouts[forestKey].trees.push({
                                    dx: (seededRandom(c_forest, r_forest, tS + 1) - 0.5) * TILE_WIDTH_HALF * 0.7,
                                    dy: (seededRandom(c_forest, r_forest, tS + 2) - 0.5) * TILE_HEIGHT_HALF * 0.5,
                                    scale: 0.7 + seededRandom(c_forest, r_forest, tS + 3) * 0.6
                                });
                            }
                            featureLayouts[forestKey].trees.sort((a, b) => (screenYBase_forest + a.dy) - (screenYBase_forest + b.dy));
                        }
                    }
                }

                // 3. Generate train path
                trainPath=[];if(placedCitiesCoords.length>=2){
                    placedCitiesCoords.sort((a,b) => { if (a.x !== b.x) return a.x - b.x; return a.y - b.y; });
                    for(let i=0;i<placedCitiesCoords.length-1;i++){ 
                        const sC=placedCitiesCoords[i];const eC=placedCitiesCoords[i+1]; 
                        const seg=aStar(sC,eC,mapData,MAP_COLS,MAP_ROWS); 
                        if(seg && validatePathSegment(seg, mapData)){
                            if(trainPath.length===0)trainPath.push(...seg);else trainPath.push(...seg.slice(1));
                        } else {
                            console.warn(`No valid path: ${sC.name} to ${eC.name}`); 
                            if(seg)console.error("A* path failed validation!",seg);
                        }
                    }
                }
                if(trainPath.length<2){console.warn("Final trainPath too short or failed, using fallback path.");const m=Math.min(Math.floor(MAP_COLS/5),Math.floor(MAP_ROWS/5),3); const c1=m;const r1=m;const c2=MAP_COLS-1-m;const r2=MAP_ROWS-1-m;trainPath=[]; if(c2>c1&&r2>r1){for(let c=c1;c<=c2;c++)trainPath.push({x:c,y:r1});for(let r=r1+1;r<=r2;r++)trainPath.push({x:c2,y:r});for(let c=c2-1;c>=c1;c--)trainPath.push({x:c,y:r2});for(let r=r2-1;r>r1;r--)trainPath.push({x:c1,y:r});trainPath.push({x:c1,y:r1});} else trainPath=[{x:0,y:0},{x:1,y:0},{x:1,y:1},{x:0,y:1},{x:0,y:0}];}
                train.segmentIndex=0;train.progress=0;
            }

            // --- Drawing Tracks, Train (condensed) ---
            function drawTracks() { if(trainPath.length<2)return;ctx.strokeStyle=COLORS.track;ctx.lineWidth=5;ctx.lineCap="round";ctx.lineJoin="round";ctx.beginPath();const fP=isoToScreen(trainPath[0].x,trainPath[0].y);ctx.moveTo(fP.x,fP.y);for(let i=1;i<trainPath.length;i++){const p=isoToScreen(trainPath[i].x,trainPath[i].y);ctx.lineTo(p.x,p.y);}ctx.stroke();}
            function updateTrain() {
                if(trainPath.length<2)return;
                
                // Calculate actual distance for wheel rotation sync
                const currentSegmentIdx = train.segmentIndex;
                const nextSegmentIdx = (currentSegmentIdx + 1) % (trainPath.length - 1);
                const p1 = isoToScreen(trainPath[currentSegmentIdx].x, trainPath[currentSegmentIdx].y);
                const p2 = isoToScreen(trainPath[nextSegmentIdx].x, trainPath[nextSegmentIdx].y);
                const segmentDistance = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
                
                train.progress += train.speed;
                
                // Sync wheel rotation to actual movement distance - wheels should spin much faster
                const wheelRadius = TILE_HEIGHT_HALF * 0.7 * 0.30; // Same as in drawEngine
                const wheelCircumference = 2 * Math.PI * wheelRadius;
                train.wheelPhase += (train.speed * segmentDistance) / wheelCircumference * Math.PI * 2 * 2.5; // Extra multiplier for faster spinning
                
                if(train.progress >= 1.0){
                    train.progress -= 1.0;
                    train.segmentIndex++;
                    if(train.segmentIndex >= trainPath.length - 1){
                        train.segmentIndex = 0; 
                        train.progress = 0;
                    } 
                }
            }

            function spawnSmokeParticle(chimneyTopX, chimneyTopY, trainAngle = 0, trainSpeed = 0) {
                const lifeMax = 80 + Math.random() * 40; // Slightly longer life
                
                // Add wind drift based on train direction
                const windStrength = 0.4;
                const windX = Math.cos(trainAngle + Math.PI) * windStrength; // Opposite to train direction
                const windY = Math.sin(trainAngle + Math.PI) * windStrength * 0.3; // Less vertical wind
                
                smokeParticles.push({
                    x: chimneyTopX,
                    y: chimneyTopY,
                    vx: (Math.random() - 0.5) * 0.2 + windX, // Wind drift
                    vy: -0.2 - Math.random() * 0.3 + windY,  // Upward with wind
                    life: 0,
                    maxLife: lifeMax,
                    initialSize: 1 + Math.random() * 2, // Start smaller
                    growthRate: 1.5 + Math.random() * 0.5, // How much it grows
                    colorVal: 240 + Math.floor(Math.random() * 15), // Much whiter start color
                    turbulence: Math.random() * 0.1 // Random movement
                });
            }

            function updateSmokeParticles() {
                for (let i = smokeParticles.length - 1; i >= 0; i--) {
                    const p = smokeParticles[i];
                    
                    // Add slight turbulence for more realistic movement
                    const turbulenceX = (Math.random() - 0.5) * p.turbulence;
                    const turbulenceY = (Math.random() - 0.5) * p.turbulence;
                    
                    p.x += p.vx + turbulenceX;
                    p.y += p.vy + turbulenceY;
                    
                    // Gradually slow down horizontal movement (air resistance)
                    p.vx *= 0.995;
                    p.vy *= 0.998; // Slight upward deceleration
                    
                    p.life++;
                    if (p.life >= p.maxLife) {
                        smokeParticles.splice(i, 1);
                    }
                }
            }

            function drawTrain() {
                if(trainPath.length<2) return;
                const carriageBodyWidth = TILE_WIDTH_HALF * 0.65; 
                const carriageBodyHeight = TILE_HEIGHT_HALF * 0.75;

                // Store carriage positions for coupler drawing
                const carriagePositions = [];

                for(let k = 0; k < train.numCarriages; k++) {
                    let currentCarriageProgress;
                    if (k === 0) {
                        // Locomotive - no offset
                        currentCarriageProgress = train.progress;
                    } else if (k === 1) {
                        // First car after locomotive - add small extra spacing to match visual gap between other cars
                        // Locomotive is 1.4x longer, so we need about 0.2-0.3 extra spacing
                        currentCarriageProgress = train.progress - (train.carriageSpacingProgress + 0.25);
                    } else {
                        // Subsequent cars - standard spacing plus the initial extra gap
                        currentCarriageProgress = train.progress - ((k - 1) * train.carriageSpacingProgress + train.carriageSpacingProgress + 0.25);
                    }
                    let currentCarriageSegmentIdx = train.segmentIndex;

                    while(currentCarriageProgress < 0) {
                        const numSegments = trainPath.length > 1 ? trainPath.length - 1 : 1;
                        currentCarriageSegmentIdx = (currentCarriageSegmentIdx - 1 + numSegments) % numSegments;
                        currentCarriageProgress += 1.0; 
                    }
                    
                    if (currentCarriageSegmentIdx < 0 || currentCarriageSegmentIdx >= trainPath.length - 1) {
                        continue; 
                    }

                    const p1 = isoToScreen(trainPath[currentCarriageSegmentIdx].x, trainPath[currentCarriageSegmentIdx].y);
                    const p2 = isoToScreen(trainPath[currentCarriageSegmentIdx + 1].x, trainPath[currentCarriageSegmentIdx + 1].y);

                    const carX = p1.x + (p2.x - p1.x) * currentCarriageProgress;
                    const carY = p1.y + (p2.y - p1.y) * currentCarriageProgress;
                    
                    const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                    // Flip if the train is moving left-ish on screen (dx_screen < 0)
                    const facingDown = Math.abs(angle) > Math.PI/2;
                    const verticalAdjust = facingDown ? -1 : 1; // This verticalAdjust is not directly used by car drawing functions anymore, but good to keep consistent if any part refers to it.

                    // Store position for coupler drawing
                    carriagePositions.push({ x: carX, y: carY, angle: angle });

                    const carriageType = train.carriageTypes[k] || 'freight';
                    const carWidth = carriageBodyWidth * (carriageType === 'engine' ? 1.4 : 1); 
                    const carHeight = carriageBodyHeight * (carriageType === 'engine' ? 1.15 : 1);

                    // Draw the appropriate carriage type
                        ctx.save(); 
                        ctx.translate(carX, carY); 
                        ctx.rotate(angle);         
                    if (facingDown) {
                        ctx.scale(1, -1); // Flip vertically to keep cars upright in both directions
                    }
                    
                    const adj = 1; // Always draw upright
                    
                    switch(carriageType) {
                        case 'engine':
                            drawEngine(ctx, carWidth, carHeight, train.wheelPhase, adj);
                            break;
                        case 'passenger':
                            drawPassengerCar(ctx, carWidth, carHeight, train.wheelPhase, adj);
                            break;
                        case 'freight':
                            drawFreightCar(ctx, carWidth, carHeight, train.wheelPhase, adj);
                            break;
                        case 'tank':
                            drawTankCar(ctx, carWidth, carHeight, train.wheelPhase, adj);
                            break;
                        case 'caboose':
                            drawCaboose(ctx, carWidth, carHeight, train.wheelPhase, adj);
                            break;
                        default:
                            drawFreightCar(ctx, carWidth, carHeight, train.wheelPhase, adj);
                    }
                    ctx.restore();

                    // Handle engine smoke
                    if (carriageType === 'engine') {
                        const smokestackWidth = carWidth * 0.15;
                        const smokestackHeight = carHeight * 0.7;
                        
                        const baseSmokestackLocalY = -(carHeight / 2 + smokestackHeight / 2);
                        const localSmokestackX = carWidth * 0.30;
                        const localSmokestackY = baseSmokestackLocalY * verticalAdjust;

                        const rotatedSmokestackOffsetX = localSmokestackX * Math.cos(angle) - localSmokestackY * Math.sin(angle);
                        const rotatedSmokestackOffsetY = localSmokestackX * Math.sin(angle) + localSmokestackY * Math.cos(angle);

                        const smokestackScreenX = carX + rotatedSmokestackOffsetX;
                        const smokestackScreenY = carY + rotatedSmokestackOffsetY;

                        // Draw smokestack
                        ctx.save();
                        ctx.translate(smokestackScreenX, smokestackScreenY);
                        ctx.fillStyle = COLORS.smokestack;
                        ctx.fillRect(-smokestackWidth / 2, -smokestackHeight / 2, smokestackWidth, smokestackHeight);
                        ctx.restore();
                        
                        // Spawn smoke
                        const wheelRotationCycle = (train.wheelPhase % (Math.PI * 2)) / (Math.PI * 2);
                        const puffRate = 1.5 + train.speed * 4;
                        
                        if (Math.random() < puffRate && wheelRotationCycle < 0.7) {
                           spawnSmokeParticle(
                               smokestackScreenX, 
                               smokestackScreenY - smokestackHeight / 2,
                               angle,
                               train.speed
                           );
                        }
                    }
                }
            }

            function drawSmokeParticles() {
                smokeParticles.forEach(p => {
                    const lifeRatio = p.life / p.maxLife;
                    
                    // More realistic alpha fade (starts strong, fades faster at end)
                    const alpha = Math.pow(1 - lifeRatio, 1.5);
                    
                    // Grows more dramatically
                    const currentSize = p.initialSize * (1 + lifeRatio * p.growthRate);
                    
                    // Keep smoke whiter throughout its life - less darkening
                    const baseColor = Math.floor(p.colorVal * (0.95 - lifeRatio * 0.15));
                    
                    // Pure white smoke - no blue tint
                    const r = baseColor;
                    const g = baseColor;
                    const b = baseColor;
                    
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${Math.max(0, alpha * 0.7)})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, currentSize, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            // --- Main Game Loop ---
            function gameLoop(){update();draw();requestAnimationFrame(gameLoop);}
            function update(){
                updateTrain();
                updateSmokeParticles();
            }

            function draw() {
                ctx.fillStyle = COLORS.sky;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Layer 1: Base ground tiles
                for (let r_draw = 0; r_draw < MAP_ROWS; r_draw++) {
                    for (let c_draw = 0; c_draw < MAP_COLS; c_draw++) {
                        const tileType = mapData[r_draw][c_draw];
                        const { x: screenX, y: screenY } = isoToScreen(c_draw, r_draw);
                        
                        switch (tileType) {
                            case TILE_TYPE.GRASS: drawDiamond(screenX, screenY, COLORS.grass, LightenDarkenColor(COLORS.grass, -30)); break;
                            case TILE_TYPE.WATER: drawDiamond(screenX, screenY, COLORS.water, LightenDarkenColor(COLORS.water, -30)); break;
                            case TILE_TYPE.SAND: drawDiamond(screenX, screenY, COLORS.sand, LightenDarkenColor(COLORS.sand, -30)); break;
                            case TILE_TYPE.CITY: drawDiamond(screenX, screenY, COLORS.cityGround, LightenDarkenColor(COLORS.cityGround, -20)); break;
                            case TILE_TYPE.MOUNTAIN: case TILE_TYPE.FOREST: drawDiamond(screenX, screenY, COLORS.grass, LightenDarkenColor(COLORS.grass, -30)); break;
                        }
                    }
                }

                // Layer 2: Tracks
                drawTracks(); 
                
                // Layer 3: Train (drawn BEFORE features)
                drawTrain(); 

                // Layer 3.5: Smoke Particles (drawn after train, before tall features)
                drawSmokeParticles();
                
                // Layer 4: Features (actual vertical parts of cities, mountains, forests) & City Names
                for (let r_draw = 0; r_draw < MAP_ROWS; r_draw++) {
                    for (let c_draw = 0; c_draw < MAP_COLS; c_draw++) {
                        const tileType = mapData[r_draw][c_draw];
                        if (tileType === TILE_TYPE.CITY) {
                            drawCityBuildingsOnly(c_draw, r_draw); 
                            drawCityName(c_draw, r_draw); 
                        } else if (tileType === TILE_TYPE.MOUNTAIN) {
                            drawMountainFeatureOnly(c_draw, r_draw); 
                        } else if (tileType === TILE_TYPE.FOREST) {
                            drawForestTreesOnly(c_draw, r_draw); 
                        }
                    }
                }
            }

            function init(){generateMap();gameLoop();}
            init(); 
        };
    </script>
</body>
</html>